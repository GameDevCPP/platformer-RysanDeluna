## Introduction

This document describes the game Tile Running, which is designed to be a simple, 2D grid game, constructed and designed to study different types of AI in a grid-like environment while playing a 'mouse and rat' game. The game employs a grid environment with different levels, each one with its own objectives, enemies, AI algorithms, collectible items, and memory and scene management. 

## Technology

The game was developed with PC's in mind, but it can be easily ported to other platforms as it programmed in C++. The Game Engine was built above the SFML library, which provided the foundation for I/O handling. The Game Engine consists of:

- **System Renderer**: controls the presentation of elements present within a scene;
- **System Resources**: responsable to import external assets, as fonts, sounds and textures.
- **Engine**: handles initialization of the systems and scenes.
- **Level Tile Loader**: builds the level layout based on a text file that represents the map, e.g. walls, objectives, player spawn, enemies spawn etc.
- **Maths library**: extension of SFML namespace, utilized for making mathematical operations with 2D vectors.
- **Entity/Component Library**: the basis for game systems and interactions between different elements by providing a framework in which each *entity* behaves and acts based on its *components*. The Fly-Weight pattern is implemented on this library, as each entity is constructed based on its own characteristics.

The artwork is entirely generated by simple shapes provided by SFML, that being squares, rectangles and circles. These can be quickly adapted to comport external assets by using the **Resources**+**Renderer** systems.   

## Backstory

After stealing chemical compounds from a pharmaceutical company in a plain 2D world, **Green Square** (you) need to run away with it avoiding getting caught by the smart **Graph Search Force** dressed in Magenta. Sadly, **Green** is not very good handling hazardous liquids, what can leave **Yellow** squared slimes behind it, who are very toxic! Meanwhile, it is useful to get **Blue Circle** water on the way, so **Green** gets faster.  

## Objective

- Get all blue collectibles and reach the red square while avoiding getting caught by either the Yellow or Magenta squares.


## Gameplay

The game works above a grid-like environment with top-down view of the tiles, in which every character can only move to the neighbour tile. The movement can be only up, down, left or right at a time. 

All the tiles are passable, the only exception being the walls and enemies. **Green** is not so resistant, so it will instantly die by touching an enemy or hazardous slime. Speaking of, the two different enemies work as it's described bellow:

- **Magenta**: will go after Green or Water by the best path found on the grid.
- **Yellow**: they will follow Green's pace and path, being always behind it. This type of enemy can kill the Magenta.

The collectibles are circular, blue tiles that they give more speed to Green and the Magenta, while also unlocking the door to the next level. So it is important to collect as much as you can before the Magenta do!

## Levels

There are five levels programmed and they were made on a text file as well as programmed on the source code. 

1. **Introduction**: a straight forward road to the Red tile, enemies around the player and they will start to move after a few seconds.
2. **Labyrinth**: One Magenta lurks behind one of the labyrinth walls. The Red is by the end of it.
3. **Hazardous Smiles and Water**: Just like the first level, but now the enemies are Yellows and Green needs to drink Water.
4. **Another Labyrinth**: In another labyrinth, Green needs to grab water while avoid the Yellow smiles.
5. **Altogether**: The last level and final challenge, the Magenta track down Green and now it needs to deal with both the Magenta as well as the Yellow, while thirsty!


## Controls

The commands are implemented within the player's movement component and additional keys specific to each scene are implemented within it's update function. 

- UP/W: goes north;
- LEFT/A: goes west;
- RIGHT/D: goes east;
- DOWN/S: goes down;
- N: skips level (cheat code if needed).


## GUI/In-game menu

The GUI is implemented only in the main menu with the usage of buttons. These were programmed using a component that controls input and changes from scenes that connects to the Main Menu. 


## Artwork

The artwork is generated entirely by mathematical function within the Tile Level Loader, that generated the sprites utilized for drawing the levels. Shapes were based on the SFML library. 
