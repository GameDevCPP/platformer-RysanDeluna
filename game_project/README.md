# Game Design Document

## Introduction

This document describes the game Tile Running, which is designed to be a simple, 2D grid game, constructed and designed to study different types of AI in a grid-like environment while playing a 'mouse and rat' game. The game employs a grid environment with different levels, each one with its own objectives, enemies, AI algorithms, collectible items, and memory and scene management. 

## Technology

The game was developed with PC's in mind, but it can be easily ported to other platforms as it programmed in C++. The Game Engine was built above the SFML library, which provided the foundation for I/O handling. The Game Engine consists of:

- **System Renderer**: controls the presentation of elements present within a scene;
- **System Resources**: responsable to import external assets, as fonts, sounds and textures.
- **Engine**: handles initialization of the systems and scenes.
- **Level Tile Loader**: builds the level layout based on a text file that represents the map, e.g. walls, objectives, player spawn, enemies spawn etc.
- **Maths library**: extension of SFML namespace, utilized for making mathematical operations with 2D vectors.
- **Entity/Component Library**: the basis for game systems and interactions between different elements by providing a framework in which each *entity* behaves and acts based on its *components*. The Fly-Weight pattern is implemented on this library, as each entity is constructed based on its own characteristics.

The artwork is entirely generated by simple shapes provided by SFML, that being squares, rectangles and circles. These can be quickly adapted to comport external assets by using the **Resources**+**Renderer** systems.   

## Backstory

After stealing chemical compounds from a pharmaceutical company in a plain 2D world, **Green Square** (you) need to run away with it avoiding getting caught by the smart **Graph Search Force** dressed in Magenta. Sadly, **Green** is not very good handling hazardous liquids, what can leave **Yellow** squared slimes behind it, who are very toxic! Meanwhile, it is useful to get **Blue Circle** water on the way, so **Green** gets faster.  

## Objective

- Get all blue collectibles and reach the red square while avoiding getting caught by either the Yellow or Magenta squares.


## Gameplay

The game works above a grid-like environment with top-down view of the tiles, in which every character can only move to the neighbour tile. The movement can be only up, down, left or right at a time. 

All the tiles are passable, the only exception being the walls and enemies. **Green** is not so resistant, so it will instantly die by touching an enemy or hazardous slime. Speaking of, the two different enemies work as it's described bellow:

- **Magenta**: will go after Green or Water by the best path found on the grid.
- **Yellow**: they will follow Green's pace and path, being always behind it. This type of enemy can kill the Magenta.

The collectibles are circular, blue tiles that they give more speed to Green and the Magenta, while also unlocking the door to the next level. So it is important to collect as much as you can before the Magenta do!

## Levels

There are five levels programmed and they were made on a text file as well as programmed on the source code. 

1. **Introduction**: a straight forward road to the Red tile, enemies around the player and they will start to move after a few seconds.
2. **Labyrinth**: One Magenta lurks behind one of the labyrinth walls. The Red is by the end of it.
3. **Hazardous Smiles and Water**: Just like the first level, but now the enemies are Yellows and Green needs to drink Water.
4. **Another Labyrinth**: In another labyrinth, Green needs to grab water while avoid the Yellow smiles.
5. **Altogether**: The last level and final challenge, the Magenta track down Green and now it needs to deal with both the Magenta as well as the Yellow, while thirsty!


## Controls

The commands are implemented within the player's movement component and additional keys specific to each scene are implemented within it's update function. 

- UP/W: goes north;
- LEFT/A: goes west;
- RIGHT/D: goes east;
- DOWN/S: goes down;
- N: skips level (cheat code if needed).


## GUI/In-game menu

The GUI is implemented only in the main menu with the usage of buttons. These were programmed using a component that controls input and changes from scenes that connects to the Main Menu. 


## Artwork

The artwork is generated entirely by mathematical function within the Tile Level Loader, that generated the sprites utilized for drawing the levels. Shapes were based on the SFML library. 

# Development Process

The beginning of the development process surrounded understanding the "in's and out's" of the framework as well as how the algorithms for the AI worked. For this, the first step was drafting a class diagram that could explain how the classes interacts with each other. It can be seen bellow:

![image](https://github.com/GameDevCPP/platformer-RysanDeluna/assets/82891214/a509729d-c6e8-4cd7-92cb-7e4a2ffd0472)

The diagram shows how the framework was first developed to the Platformer game, but it gives a general idea of how the different systems interact with each other, as well as how the entity/component design works.
This was the base for what would become TILE RUNNING.

## Regarding the AI 

By studying how an pathfinding algorithm would work, it was decided that the game would be better suited in a grid-like map, as the graph implementation would be much easier.
As the tiles are not weighted, the Dijsktra Algorithm or the A* were not considered. 

Furthermore, this type of AI guided the decision for approaching a top-down view of the grid and the construction of the levels, which are made with how the AI works.

The AI code is mainly inside the components relevant to them, but the graph implementation is found within an AI directory.

## Additions to the framework

Some components were added beyond what was given by the framework. These are:

- BFS_AI: adds to the ActorMovementComponent by implementing the breadth first search and making the movements based on the path found.
- Collectables: component responsable to delete the entity and power other entities with the ActorMovementComponent
- Kill: this component makes the owner entity to kill another determined type of entity, auto-destroying itself in the process.
- Pursuer_AI: when an Entity owns this component, it will mimic the movements made by another entity; a better of making this work is spawning the parent on the same tile as the mimicking target.

Besides the components development, some changes were made on the already given source codes.

- Tile Loader:
  - Now the tiles possess a outline color and empty tiles have a gray outline;
  - A function that returns the grid coordinates of a float position;
  - The optimise function is only active to the WALL and END tiles.

- Text Component:
  - It is positioned wherever it's parent is.

## Levels Development

The levels follow the rule of first introducing a simple mechanic, followed by a much harder experience with that single mechanic. For example, the first level introduces the Type 1 enemy, while the second level is a maze with that kind of enemy. The same is done for further mechanics.

The mazes were based on the [dungeon generator made by Donjon](https://donjon.bin.sh/d20/dungeon/) with alterations that would make a better gaming experience.
